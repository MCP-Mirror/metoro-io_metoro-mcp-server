package main

import (
	"fmt"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"os"
)

var handlers = map[string]server.ToolHandlerFunc{
	"get_environments":     getEnvironmentsHandler,    // resource
	"get_services":         getServicesHandler,        // resource
	"get_namespaces":       getNamespacesHandler,      // resource
	"get_logs":             getLogsHandler,            // tool
	"get_traces":           getTracesHandler,          // tool
	"get_metric":           getMetricHandler,          // tool
	"get_trace_metric":     getTraceMetricHandler,     // tool
	"get_trace_attributes": getTraceAttributesHandler, // resource
	"get_trace_attribute_values_for_individual_attribute": getTraceAttributeValuesForIndividualAttributeHandler, // tool
	"get_profiles":              getProfilesHandler,            // tool
	"get_k8s_events":            getK8sEventsHandler,           // tool
	"get_k8s_events_attributes": getK8sEventsAttributesHandler, // resource
	"get_k8s_event_attribute_values_for_individual_attribute": getK8sEventAttributeValuesForIndividualAttributeHandler, // tool
	"get_k8s_events_volume":                                   getK8sEventsVolumeHandler,                               // tool
	"get_metricAttributes":                                    getMetricAttributesHandler,                              //resource
	"get_metric_names":                                        getMetricNamesHandler,                                   // resource
	"get_metric_metadata":                                     getMetricMetadata,                                       // resource
	"get_pods":                                                getPodsHandler,                                          // tool
	"get_k8s_service_information":                             getK8sServiceInformationHandler,                         // tool
	"get_log_attributes":                                      getLogAttributesHandler,                                 // resource
	"get_log_attribute_values_for_individual_attribute":       getLogAttributeValuesForIndividualAttributeHandler,      // tool
	"get_nodes":                                               getNodesHandler,                                         // tool
	"get_node_info":                                           getNodeInfoHandler,                                      // tool
	"get_service_summaries":                                   getServiceSummariesHandler,                              // tool
	"get_alerts":                                              getAlertsHandler,                                        // tool
	"get_alert_fires":                                         getAlertFiresHandler,                                    // tool
}

var tools = []mcp.Tool{
	mcp.NewTool("get_environments",
		mcp.WithDescription("Get Kubernetes environments/clusters, monitored by Metoro"),
	),
	mcp.NewTool("get_services",
		mcp.WithDescription("Get services running in your Kubernetes cluster, monitored by Metoro"),
	),
	mcp.NewTool("get_namespaces",
		mcp.WithDescription("Get namespaces in your Kubernetes cluster, monitored by Metoro"),
	),
	mcp.NewTool("get_logs",
		mcp.WithDescription("Get logs from all/any services/hosts/pods running in your Kubernetes cluster in the last 5 minutes, monitored by Metoro"),
		// TODO: Fix the issue with 5 minutes hardcoded
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the logs. It is a stringified map[string]string[], e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return logs for serviceX in namespaceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the logs. It is a stringified map[string]string[] e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return all logs except for serviceX in namespaceX"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes as a string to filter logs based on a regex inclusively"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes as a string to filter logs based on a regex exclusively"),
		),
		mcp.WithBoolean("ascending",
			mcp.Description("Whether to return logs in ascending order or not"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of cluster/environments as a string. If empty, all clusters will be included"),
		),
	),
	mcp.NewTool("get_traces",
		mcp.WithDescription("Get traces from services running in your Kubernetes cluster in the last 5 minutes, monitored by Metoro"),
		mcp.WithString("serviceNames",
			mcp.Description("JSON array of service names as a string to filter traces for specific services"),
		),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the traces. It is a stringified map[string]string[], e.g., '{\"server.service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return server traces for serviceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the traces. It is a stringified map[string]string[] e.g., '{\"server.service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return all traces except for serviceX running in namespaceX"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes as a string to filter traces based on a regex inclusively"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes as a string to filter traces based on a regex exclusively"),
		),
		mcp.WithBoolean("ascending",
			mcp.Description("Whether to return traces in ascending order or not"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of cluster/environments as a string. If empty, all clusters will be included"),
		),
	),
	mcp.NewTool("get_metric",
		mcp.WithDescription("Get timeseries data of metrics from your Kubernetes cluster"),
		mcp.WithString("metricName",
			mcp.Description("The name of the metric to get"),
			mcp.Required(),
		),
		// TODO: Fix the issue with startTime and endTime
		//mcp.WithNumber("startTime",
		//	mcp.Description("Start time of when to get the metrics in seconds since epoch"),
		//),
		//mcp.WithNumber("endTime",
		//	mcp.Description("End time of when to get the metrics in seconds since epoch"),
		//),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the metrics. It is a stringified map[string]string[], e.g., '{\"service.name\": [\"serviceX\"]}' should return metrics for serviceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the metrics. It is a stringified map[string]string[] e.g., '{\"service.name\": [\"serviceX\"]}' should return all metrics except for serviceX"),
		),
		mcp.WithString("splits",
			mcp.Description("JSON array of attributes to split the metrics by, e.g., '[\"service_name\"]' to split metrics by service"),
		),
		mcp.WithString("aggregation",
			mcp.Description("The aggregation to apply to the metrics,  e.g. sum, avg, max, min"),
			mcp.Required(),
		),
		mcp.WithString("functions",
			mcp.Description("JSON array of functions to apply to the metrics"),
		),
		mcp.WithBoolean("limitResults",
			mcp.Description("Whether to limit the results or not"),
		),
		mcp.WithNumber("bucketSize",
			mcp.Description("The size of each datapoint bucket in seconds, if not provided metoro will select the best bucket size for the given duration for performance and clarity"),
		),
	),
	mcp.NewTool("get_trace_metric",
		mcp.WithDescription("Get trace metrics from your Kubernetes cluster, monitored by Metoro"),
		//mcp.WithString("serviceNames",
		//	mcp.Description("JSON array of service names to filter traces by"),
		//),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the traces. It is a stringified map[string]string[], e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return traces for serviceX in namespaceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the traces. It is a stringified map[string]string[] e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return all traces except for serviceX in namespaceX"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes as a string to filter traces based on a regex inclusively"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes as a string to filter traces based on a regex exclusively"),
		),
		mcp.WithString("splits",
			mcp.Description("JSON array of strings to split the trace metrics by"),
		),
		mcp.WithString("functions",
			mcp.Description("JSON array of functions to apply to the trace metrics"),
		),
		mcp.WithString("aggregate",
			mcp.Description("The aggregation to apply to the trace metrics, e.g. count, sum, avg, max, min, p50, p90, p99, p95"),
			mcp.Required(),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter traces by"),
		),
		mcp.WithBoolean("limitResults",
			mcp.Description("Whether to limit the results or not"),
		),
		mcp.WithNumber("bucketSize",
			mcp.Description("The size of each datapoint bucket in seconds, if not provided, metoro will select the best bucket size for performance and clarity"),
		),
	),
	mcp.NewTool("get_trace_attributes",
		mcp.WithDescription("Get all available trace attributes that can be used for filtering or grouping traces"),
	),
	mcp.NewTool("get_trace_attribute_values_for_individual_attribute",
		mcp.WithDescription("Get all possible values for a specific trace attribute with optional filtering"),
		mcp.WithString("attribute",
			mcp.Description("The attribute to get values for"),
			mcp.Required(),
		),
		mcp.WithString("serviceNames",
			mcp.Description("JSON array of service names to filter traces by"),
		),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the traces. It is a stringified map[string]string[], e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return traces for serviceX in namespaceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the traces. It is a stringified map[string]string[] e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return all traces except for serviceX in namespaceX"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes as a string to filter traces based on a regex inclusively"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes as a string to filter traces based on a regex exclusively"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter traces by"),
		),
	),
	mcp.NewTool("get_profiles",
		mcp.WithDescription("Get profiling data from services running in your Kubernetes cluster which will help you understand where your service is spending time"),
		mcp.WithString("serviceName",
			mcp.Description("The name of the service to get profiles for"),
		),
		mcp.WithString("containerNames",
			mcp.Description("JSON array of container names to get profiles for"),
		),
	),
	mcp.NewTool("get_k8s_events",
		mcp.WithDescription("Get Kubernetes events from your clusters with filtering options"),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the k8s events. It is a stringified map[string]string[], e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return k8s events for serviceX in namespaceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the k8s events. It is a stringified map[string]string[] e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return all k8s events except for serviceX in namespaceX"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes as a string to filter k8s events based on a regex inclusively"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes as a string to filter k8s events based on a regex exclusively"),
		),
		mcp.WithBoolean("ascending",
			mcp.Description("Whether to return k8s events in ascending order or not"),
		),
		mcp.WithNumber("prevEndTime",
			mcp.Description("Previous page endTime in nanoseconds, used for pagination if there are more k8s events than the page size"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter k8s events by"),
		),
	),
	mcp.NewTool("get_k8s_events_attributes",
		mcp.WithDescription("Get all available Kubernetes event attributes that can be used for filtering or grouping events"),
	),
	mcp.NewTool("get_k8s_event_attribute_values_for_individual_attribute",
		mcp.WithDescription("Get all possible values for a specific Kubernetes event attribute with optional filtering"),
		mcp.WithString("attribute",
			mcp.Description("The attribute to get values for"),
			mcp.Required(),
		),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the k8s events. It is a stringified map[string]string[], e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return k8s events for serviceX in namespaceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the k8s events. It is a stringified map[string]string[] e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return all k8s events except for serviceX in namespaceX"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes as a string to filter k8s events based on a regex inclusively"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes as a string to filter k8s events based on a regex exclusively"),
		),
		mcp.WithBoolean("ascending",
			mcp.Description("Whether to return k8s events in ascending order or not"),
		),
		mcp.WithNumber("prevEndTime",
			mcp.Description("Previous page endTime in nanoseconds, used for pagination if there are more k8s events than the page size"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter k8s events by"),
		),
	),
	mcp.NewTool("get_k8s_events_volume",
		mcp.WithDescription("Get the volume of Kubernetes events from your clusters"),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the k8s events. It is a stringified map[string]string[], e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return k8s events for serviceX in namespaceX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the k8s events. It is a stringified map[string]string[] e.g., '{\"service.name\": [\"/k8s/namespaceX/serviceX\"]}' should return all k8s events except for serviceX in namespaceX"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes as a string to filter k8s events messages based on a regex inclusively"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes as a string to filter k8s events messages based on a regex exclusively"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter k8s events by"),
		),
	),
	mcp.NewTool("get_pods",
		mcp.WithDescription("Get pods information for either a specific service (deployment, daemonset, statefulset) or a specific node"),
		mcp.WithString("serviceName",
			mcp.Description("Name of the service (service is K8s resource type of either deployment, daemonset, statefulset) to get pod information for. If this is provided, nodeName should be empty"),
		),
		mcp.WithString("nodeName",
			mcp.Description("Name of the node to get the pods that are running on this node. If this is provided, serviceName should be empty"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter pods by"),
		),
	),
	mcp.NewTool("get_k8s_service_information",
		mcp.WithDescription("Get detailed information about a Kubernetes service including its type (Deployment, DaemonSet, etc.), YAML configuration, and current running replicas (excluding HPA)"),
		mcp.WithString("serviceName",
			mcp.Description("Name of the service to get information for (must be a Deployment, DaemonSet, or StatefulSet)"),
			mcp.Required(),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter service information by"),
		),
	),
	mcp.NewTool("get_node_info",
		mcp.WithDescription("Get detailed information about a specific node/instance in the cluster"),
		mcp.WithString("nodeName",
			mcp.Description("Name of the node to get information for"),
			mcp.Required(),
		),
	),
	mcp.NewTool("get_nodes",
		mcp.WithDescription("Lists all the nodes/instances that are running in the cluster/environment during a specified time period"),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments/clusters to filter nodes by"),
		),
		mcp.WithString("filters",
			mcp.Description("The filters to apply to the nodes. It is a stringified map[string]string[], e.g., '{\"node.name\": [\"nodeX\"]}' should return information for nodeX"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("The filters that should be excluded from the nodes. It is a stringified map[string]string[] e.g., '{\"node.name\": [\"nodeX\"]}' should return all nodes except for nodeX"),
		),
		mcp.WithString("splits",
			mcp.Description("JSON array of attributes to split the nodes by"),
		),
	),
	mcp.NewTool("get_log_attributes",
		mcp.WithDescription("Get a list of available log attributes that can be used for filtering logs. Note that this returns the default attributes, but logs can be filtered by any additional attributes present in the logs."),
	),
	mcp.NewTool("get_log_attribute_values_for_individual_attribute",
		mcp.WithDescription("Get all possible values for a specific log attribute with comprehensive filtering options"),
		mcp.WithString("attribute",
			mcp.Description("The log attribute to get values for"),
			mcp.Required(),
		),
		mcp.WithString("filters",
			mcp.Description("JSON object of filters to apply. Format: {\"attribute_name\": [\"value1\", \"value2\"]}"),
		),
		mcp.WithString("excludeFilters",
			mcp.Description("JSON object of filters to exclude. Format: {\"attribute_name\": [\"value1\", \"value2\"]}"),
		),
		mcp.WithString("regexes",
			mcp.Description("JSON array of regexes to filter log messages"),
		),
		mcp.WithString("excludeRegexes",
			mcp.Description("JSON array of regexes to exclude from log messages"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter logs by"),
		),
	),
	mcp.NewTool("get_metricAttributes",
		mcp.WithDescription("Get available metric attributes that can be used for filtering or grouping by for a specific metric"),
		mcp.WithString("metricName",
			mcp.Description("The name of the metric to get attributes for"),
			mcp.Required(),
		),
		mcp.WithString("filterAttributes",
			mcp.Description("JSON string of filter attributes in the format {\"attributeKey\": [\"value1\", \"value2\"]}"),
		),
	),
	mcp.NewTool("get_metric_names",
		mcp.WithDescription("Get all available metric names"),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments to filter by. If empty, all environments are included"),
		),
	),
	mcp.NewTool("get_metric_metadata",
		mcp.WithDescription("Get detailed metadata about a specific metric including its type, unit, and description"),
		mcp.WithString("name",
			mcp.Description("The name of the metric to get metadata for"),
			mcp.Required(),
		),
	),
	mcp.NewTool("get_service_summaries",
		mcp.WithDescription("Get RED metrics (Request count, Error rate, Duration) and other summary information about services running in the cluster"),
		mcp.WithString("namespace",
			mcp.Description("The namespace to get service summaries for. If empty, returns services from all namespaces"),
		),
		mcp.WithString("environments",
			mcp.Description("JSON array of environments/clusters to filter services by. If empty, returns services from all environments"),
		),
	),
	mcp.NewTool("get_alerts",
		mcp.WithDescription("Get information about all configured alerts including their names, descriptions, status, destinations, and types"),
	),
	mcp.NewTool("get_alert_fires",
		mcp.WithDescription("Get detailed information about all firing instances of a specific alert, including timing, messages, and metric properties"),
		mcp.WithString("alertId",
			mcp.Description("UUID of the alert to get firing instances for"),
			mcp.Required(),
		),
	),
}

func main() {
	// Check if the appropriate environment variables are set
	if err := checkEnvVars(); err != nil {
		fmt.Printf("Server error: %v\n", err)
	}

	s := server.NewMCPServer(
		"Metoro MCP Server",
		"1.0.0",
		server.WithToolCapabilities(true),
	)

	// Register all tools
	for _, tool := range tools {
		s.AddTool(tool, handlers[tool.Name])
	}

	// Start the stdio server
	if err := server.ServeStdio(s); err != nil {
		fmt.Printf("Server error: %v\n", err)
	}
}

func checkEnvVars() error {
	if os.Getenv(METORO_API_URL_ENV_VAR) == "" {
		return fmt.Errorf("%s environment variable not set", METORO_API_URL_ENV_VAR)
	}
	if os.Getenv(METORO_AUTH_TOKEN_ENV_VAR) == "" {
		return fmt.Errorf("%s environment variable not set", METORO_AUTH_TOKEN_ENV_VAR)
	}
	return nil
}
